
func _sql_agg_func(name, obj, t=null) {
    if (t==null) {
        if (isa(obj, table) and count(columns(obj))>1) {
            throw new TypeError(name + "() only accepts lists or tables with one column. Got '" + repr(type(obj)) + "'")
        }

        t = type(obj).elem
    }

    if (not (issubclass(t, number))) {
        throw new TypeError(name + "() expects numeric elements, instead got: '" + repr(t) + "'")
    }

    if (isa(obj, aggregate)) {
        return SQL(t, name + "($obj)")
    } else {
        obj = list(obj)
        if (isa(obj, list)) {
            return one one obj{ => value: _sql_agg_func(name, value, t) }     // Recursive
        }
    }
    throw new TypeError(name + "() doesn't support object of type '" + repr(type(field)) + "'")
}

// func count(field) {
//     "Count a column, a list, or a table"
//     if (isa(field, table)) {
//         return SQL(int, "SELECT COUNT(*) FROM $field")
//     }
//     return _sql_agg_func("COUNT", field)
// }

func sum(field) {
    "Sum up a column or a list"
    return _sql_agg_func("SUM", field)
}

func mean(field) {
    "Mean of a column or a list"
    return _sql_agg_func("AVG", field, float)
}

func min(field) {
    "Find the minimum of a column or a list"
    return _sql_agg_func("MIN", field)
}

func max(field) {
    "Find the maximum of a column or a list"
    return _sql_agg_func("MAX", field)
}

func first(obj) {
    "Return the first member of a column or a list"

    if (isa(obj, aggregate)) {
        return SQL(type(obj).elem, "($obj)")
    } else {
        obj = list(obj)
        if (isa(obj, list)) {
            return one one obj{ => value: first(value) }     // Recursive
        }
    }
}


func count_false(field) {
    "Count how many values in the field are false or zero"
    return SQL(int, "sum(cast($field=0 as int))")
}
func count_true(field) {
    "Count how many values in the field are true (non-zero)"
    return SQL(int, "sum(cast($field!=0 as int))")
}

func limit(tbl, n) {
    "Return the first 'n' rows in table"
    return tbl[..n]
}

func limit_offset(tbl, lim, offset) = SQL(type(tbl), "SELECT * FROM $tbl LIMIT $lim OFFSET $offset")

func enum(tbl) {
    "Return the table with a new index column"
    return tbl{index: SQL(int, "row_number() over ()"), ...}
}

func upper(s) {
    "Return a copy of the string converted to uppercase."
    return SQL(string, "upper($s)")
}

func lower(s) {
    "Return a copy of the string converted to uppercase."
    return SQL(string, "lower($s)")
}

func length(s) {
    "Return the length of the string"
    return SQL(string, "length($s)")
}

func round(n) {
    "Return a rounded float"
    return SQL(float, "round($n)")
}


func dict(...x) {
    "Construct a dictionary"
    return x
}


// Builtins hack, so they won't collide with locals. Just put them in a module
_core_limit = limit
_core_limit_offset = limit_offset
//

func distinct(t) {
    "Remove identical rows"
    return SQL(t, "SELECT distinct * FROM $t")
}

if (get_db_type() == "postgres") {
    func repeat(s, num) = SQL(string, "REPEAT($s, $num)")
    func now() = SQL(datetime, "NOW()")         // Postgres
    func random() = SQL(float, "RANDOM()")   // Postgres
    func pi() = SQL(float, "PI()")

    func str_index(a, b) = SQL(int, "POSITION($a in $b)")
} else {
    if (get_db_type() == "sqlite") {
        func repeat(s, num) = SQL(string, "replace(hex(zeroblob($num)), '00', $s)")
        func now() = SQL(datetime, "datetime('now')")   // Sqlite
        func random() = SQL(float, "abs(CAST(random() AS REAL))/9223372036854775808")
        func pi() = SQL(float, "3.141592653589793")

        func year(date) = SQL(int, "strftime('%Y', $date)")
        func month(date) = SQL(int, "strftime('%m', $date)")
        func day(date) = SQL(int, "strftime('%d', $date)")
        func hour(date) = SQL(int, "strftime('%H', $date)")
        func minute(date) = SQL(int, "strftime('%M', $date)")
        func day_of_week(date) = SQL(int, "strftime('%w', $date)")
        func week_of_year(date) = SQL(int, "strftime('%W', $date)")
        func count_distinct(field) = SQL(int, "count(distinct $field)")

        func str_index(a, b) = SQL(int, "INSTR($b, $a)")

    } else {
        throw new TypeError("Unexpected")
    }
}

func str_contains(a, b) = str_index(a, b) > 0
func str_notcontains(a, b) = str_index(a, b) == 0

func sample_ratio_fast(tbl, ratio) {
    "Return a random sample of rows from the table, at the approximate amount of (ratio*count(tbl))."
    return tbl[random() < ratio]    // random() will be re-evaluated for every row
}

func sample_fast(tbl, n, bias=0.05) {
    """Return a random sample of n rows from the table in one query (or at worst two queries)

    Higher values of 'bias' increase the chance of success in a single query,
    but may introduce a higher bias in the randomness of the chosen rows, especially in sorted tables.
    """
    c = count(tbl)
    if (n > c) {
        throw new ValueError("Asking for a sample size larger than the table")
    }
    if (bias < 0) {
        throw new ValueError("Cannot have a negative bias")
    }
    if (n <= 0) {
        throw new ValueError("n must be a number above 0")
    }

    if (n == c) {
        return tbl
    }

    const table results = sample_ratio_fast(tbl, (1+bias) * n / c)[..n]
    if (count(results) == n) {
        return results
    }
    // This should happen very rarely
    return results + limit(tbl, n - count(results))
}
