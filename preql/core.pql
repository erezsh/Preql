
func _sql_agg_func(name, obj, t=null) {
    if (isa(obj, aggregate)) {
        if (t == null) {
            t = type(obj).elemtype
        }
        return SQL(t, name + "($obj)")
    } else {
        if (isa(obj, list)) {
            if (t == null) {
                t = type(obj).elemtype
            }
            return t( obj{ => value: _sql_agg_func(name, value) } )  # Recursive
        }
    }
    throw new TypeError(name + "() doesn't support object of type '" + repr(type(field)) + "'")
}

// func count(field) {
//     "Count a column, a list, or a table"
//     if (isa(field, table)) {
//         return SQL(int, "SELECT COUNT(*) FROM $field")
//     }
//     return _sql_agg_func("COUNT", field)
// }

func sum(field) {
    "Sum up a column or a list"
    return _sql_agg_func("SUM", field)
}

func mean(field) {
    "Mean of a column or a list"
    return _sql_agg_func("AVG", field, float)
}

func min(field) {
    "Find the minimum of a column or a list"
    return _sql_agg_func("MIN", field)
}

func max(field) {
    "Find the maximum of a column or a list"
    return _sql_agg_func("MAX", field)
}

func first(field) {
    "Return the first member of a column or a list"
    return _sql_agg_func("", field)
}

func limit(tbl, n) {
    "Return the first 'n' rows in table"
    return tbl[..n]
}

func limit_offset(tbl, lim, offset) = SQL(type(tbl), "SELECT * FROM $tbl LIMIT $lim OFFSET $offset")

func enum(tbl) {
    "Return the table with a new index column"
    return tbl{index: SQL(int, "row_number() over ()"), ...}
}

func upper(s) {
    "Return a copy of the string converted to uppercase."
    return SQL(string, "upper($s)")
}

func lower(s) {
    "Return a copy of the string converted to uppercase."
    return SQL(string, "lower($s)")
}

func length(s) {
    "Return the length of the string"
    return SQL(string, "length($s)")
}

func dict(...x) {
    "Construct a dictionary"
    return x
}

// Builtins hack, so they won't collide with locals. Just put them in a module
_core_limit = limit
_core_limit_offset = limit_offset
//

if (get_db_type() == "postgres") {
    func repeat(s, num) = SQL(string, "REPEAT($s, $num)")
    func now() = SQL(datetime, "NOW()")         // Postgres
    func random() = SQL(datetime, "RANDOM()")   // Postgres
    func pi() = SQL(float, "PI()")
} else {
    if (get_db_type() == "sqlite") {
        func repeat(s, num) = SQL(string, "replace(hex(zeroblob($num)), '00', $s)")
        func now() = SQL(datetime, "datetime('now')")   // Sqlite
        func random() = SQL(float, "abs(CAST(random() AS REAL))/9223372036854775808")
        func pi() = SQL(float, "3.141592653589793")

        func year(date) = SQL(int, "strftime('%Y', $date)")
        func month(date) = SQL(int, "strftime('%m', $date)")
        func day(date) = SQL(int, "strftime('%d', $date)")
        func hour(date) = SQL(int, "strftime('%H', $date)")
        func minute(date) = SQL(int, "strftime('%M', $date)")
        func day_of_week(date) = SQL(int, "strftime('%w', $date)")
        func week_of_year(date) = SQL(int, "strftime('%W', $date)")
        func count_distinct(field) = SQL(int, "count(distinct $field)")

    } else {
        throw new TypeError("Unexpected")
    }
}

// func sample_ratio(tbl, ratio) = SQL(type(tbl), "SELECT * FROM $tbl where abs(CAST(random() AS REAL))/9223372036854775808 < $ratio")
func sample_ratio(tbl, ratio) {
    "Return a random sample of rows from the table, at the approximate amount of (ratio*count(tbl))."
    r = random()    // random() will be re-evaluated for every row
    return SQL(type(tbl), "SELECT * FROM $tbl where $r < $ratio")
}

func sample_fast(tbl, n, bias=0.05) {
    """Return a random sample of n rows from the table in one query (or at worst two queries)

    Higher values of 'bias' increase the chance of success in a single query,
    but may introduce a higher bias in the randomness of the chosen rows, especially in sorted tables.
    """
    c = count(tbl)
    if (n > c) {
        throw new ValueError("Asking for a sample size larger than the table")
    }
    if (bias < 0) {
        throw new ValueError("Cannot have a negative bias")
    }
    if (n <= 0) {
        throw new ValueError("n must be a number above 0")
    }

    if (n == c) {
        return tbl
    }

    const table results = limit(sample_ratio(tbl, (1+bias) * n / c), n)
    if (count(results) == n) {
        return results
    }
    // This should happen very rarely
    return results + limit(tbl, n - count(results))
}
