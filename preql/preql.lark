stmts: _NL? stmt+
?stmt: (table_def | struct_def | func_def | var_decl | print | if_stmt | return_stmt | throw | try_catch | expr _NL) //| add_row

table_def: "table" name "{" _sep? col_defs? "}" _NL
col_defs: (col_def _sep)* col_def _sep?
col_def: name ":" coltype ["->" expr]
?coltype: type
        | m2m
type: name [typemod]
m2m: "[" type "]"

struct_def: "struct" name "{" _sep? member_defs? "}" _NL
member_defs: (member_def _sep)* member_def _sep?
member_def: name ":" type


typemod: PK | NULLABLE

func_def: "func" name func_params ("=" expr _NL | final_codeblock)
final_codeblock: _NL stmt* "end" _NL -> codeblock
inner_codeblock: _NL stmt*           -> codeblock
if_stmt: "if" expr inner_codeblock ("end" _NL | "else" final_codeblock)
return_stmt: "return" expr _NL
throw: "throw" expr _NL
try_catch: "try" inner_codeblock "catch" expr final_codeblock
var_decl: name "=" expr _NL
print: "print" expr _NL
func_params: "(" (param ("," param)*)? ")"
param: name    // TODO type? default value?

_sep: "," | "," _NL | _NL
expr_list: "[" _NL? (expr _sep)* expr _NL? "]"
selection: molecule expr_list

projection: molecule "{" _NL? proj_exprs _NL? "}"
          | molecule "{" _NL? proj_exprs _NL? "=>" _NL? proj_exprs _NL? "}" -> projection_grouped
          | molecule "{" "=>" _NL? proj_exprs "}" -> projection_grouped_nokeys
          | molecule "{" proj_exprs _NL? "=>" "}" -> projection_grouped_novalues

proj_exprs: named_expr (_sep named_expr)* _sep?

expr_list2: (expr _sep)* expr -> expr_list
order: molecule "order" "{" _NL? expr_list2 _NL? "}"
update: molecule "update" "{" _NL? proj_exprs _NL? "}"


?expr: or_test //contains | like

// like: molecule "~" molecule

!comp_op: "<"|">"|"=="|">="|"<="|"<>"|"!="|"in"|"^in" //|"is"|"is" "not"

?or_test: and_test ("or" and_test)*
?and_test: not_test ("and" not_test)*
?not_test: "not" not_test -> not
         | compare
?compare: (compare comp_op)? like
?like: (like "~")? add_expr
?add_expr: (add_expr add_op)? term
?term: (term mul_op)? power
?factor: ("+" | "-")* molecule
?power: molecule ("**" factor)?

!add_op: "+"|"-" | "&" | "|"
!mul_op: "*"|"/"|"%"|"//"
// <> isn't actually a valid comparison operator in Python. It's here for the
// sake of a __future__ import described in PEP 401 (which really works :-)


?molecule: atom
     | func_call
     | getattr
     | list
     | selection
     | projection
     | order
     | update
     | var
     | "(" _NL? expr _NL? ")"
     | "-" molecule -> neg
     | "^" molecule -> desc
     | new

list: "[" _NL? expr (_sep expr)* _NL? "]"

new: "new" name _func_args
func_call: molecule _func_args
_func_args: "(" func_args ")"
func_args: (named_expr ("," named_expr)*)?

named_expr: [name ":"] expr

?atom: SIGNED_INT -> int
      | SIGNED_FLOAT -> float
      | STRING -> string
      | "null" -> null
      | ellipsis
      | range

range: SIGNED_INT? ".." SIGNED_INT
     | SIGNED_INT ".." SIGNED_INT?

ellipsis: "..."



getattr: molecule "." name
name: NAME
var: name

PK: "pk"
NULLABLE: "?"
COMMENT: /#[^\n]*/
_NL: ( /\r?\n[\t ]*/ | COMMENT )+

DECIMAL: INT "." INT
       | INT "." /(?![.])/
       | "." INT

_EXP: ("e"|"E") SIGNED_INT
FLOAT: INT _EXP
     | DECIMAL _EXP?
SIGNED_FLOAT: ["+"|"-"] FLOAT
SIGNED_INT: ["+"|"-"] INT


%import common.CNAME -> NAME
%import common.WS_INLINE
%import common.INT
%import common.ESCAPED_STRING -> STRING
%ignore WS_INLINE
%ignore /\\[\t \f]*\r?\n/   // LINE_CONT
%ignore COMMENT
